# nginx.conf (OpenResty 기준) - Best Practices 적용 버전

worker_processes 1;

events {
    worker_connections 1024;
}

http {
    resolver 127.0.0.11;

    lua_shared_dict redis_scripts 1m;

    init_worker_by_lua_block {
        local function load_redis_script()
            local redis = require "resty.redis"
            local red = redis:new()
            red:set_timeout(1000)

            local ok, err = red:connect("redis-server", 6379)
            if not ok then
                ngx.log(ngx.ERR, "init_worker: failed to connect to redis: ", err)
                return
            end

            local f = io.open("/etc/nginx/check_limit.lua", "r")
            if not f then
                ngx.log(ngx.ERR, "init_worker: failed to open check_limit.lua")
                return
            end
            local script_body = f:read("*a")
            f:close()

            local sha, err = red:script("LOAD", script_body)
            if not sha then
                ngx.log(ngx.ERR, "init_worker: failed to load redis script: ", err)
                return
            end
            
            ngx.shared.redis_scripts:set("check_limit_sha", sha)
            red:close()
        end

        local ok, err = ngx.timer.at(0, load_redis_script)
        if not ok then
            ngx.log(ngx.ERR, "failed to create timer for redis script loading: ", err)
        end
    }

    server {
        listen 80;

        error_page 429 @429_response;

        location /api/ {
            content_by_lua_block {
                local redis = require "resty.redis"
                
                local sha = ngx.shared.redis_scripts:get("check_limit_sha")

                if not sha then
                    ngx.log(ngx.ERR, "could not find script SHA in shared dict, waiting for init...")
                    return ngx.exit(503)
                end

                local red = redis:new()
                red:set_timeout(1000)

                local ok, err = red:connect("redis-server", 6379)
                if not ok then
                    ngx.log(ngx.ERR, "failed to connect to redis: ", err)
                    return ngx.exit(500)
                end

                local limit = 5
                local window_ms = 10000
                local now_ms = ngx.now() * 1000
                local key = "rate_limit:" .. ngx.var.remote_addr
                
                local result, err = red:evalsha(sha, 1, key, now_ms, window_ms, limit)
                
                local ok, err_keepalive = red:set_keepalive(10000, 100)
                if not ok then
                    ngx.log(ngx.ERR, "failed to set redis keepalive: ", err_keepalive)
                end

                if err and string.find(err, "NOSCRIPT") then
                    ngx.shared.redis_scripts:delete("check_limit_sha")
                    ngx.log(ngx.ERR, "NOSCRIPT error, init_worker will reload script")
                    return ngx.exit(503)
                end

                if not result then
                    ngx.log(ngx.ERR, "redis evalsha error: ", err)
                    return ngx.exit(500)
                end
                
                local current_count = tonumber(result)
                
                if current_count > limit then
                    ngx.header["X-RateLimit-Limit"] = limit
                    ngx.header["X-RateLimit-Remaining"] = 0
                    return ngx.exit(429)
                end
                
                ngx.header["X-RateLimit-Limit"] = limit
                ngx.header["X-RateLimit-Remaining"] = limit - current_count

                ngx.status = 200
                ngx.say("Sliding Window: Request processed\n")
                return
            }
        }

        location @429_response {
            return 429 "Too Many Requests\n";
        }
    }
}